import pytest
from fastapi.testclient import TestClient
import os
import sys
from datetime import datetime
import json as py_json  # For potential pretty printing if debugging again

# Adjust the import path for your FastAPI app instance
try:
    from app.main import app
except ModuleNotFoundError:
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
    from app.main import app

# Import the PDF generation helper
try:
    from .pdf_test_utils import create_structured_pdf
except ImportError:
    try:
        from pdf_test_utils import create_structured_pdf
    except ImportError:
        def create_structured_pdf(file_path: str, content_scenario: str):
            print(
                f"CRITICAL WARNING: pdf_test_utils.create_structured_pdf not found. PDF API tests will likely fail or be skipped if PDF generation is essential for {file_path}.")
            pytest.skip(
                "PDF generation utility 'create_structured_pdf' is not available. Cannot run PDF API tests that generate PDFs.")
            return None


@pytest.fixture(scope="module")
def client():
    """Create a TestClient instance for the FastAPI app."""
    with TestClient(app) as c:
        yield c


# Directory for API test specific temporary fixture files (generated PDFs)
API_TEMP_FIXTURES_BASE_DIR = os.path.join(os.path.dirname(__file__), "api_temp_fixtures")
PDF_API_GENERATED_DIR = os.path.join(API_TEMP_FIXTURES_BASE_DIR, "pdfs_generated")

if not os.path.exists(PDF_API_GENERATED_DIR):
    os.makedirs(PDF_API_GENERATED_DIR)


# --- Fixtures for PDF API tests using programmatic generation ---
@pytest.fixture
def api_generated_pdf_one_table():
    """Generates a PDF with one structured table for API testing."""
    file_path = os.path.join(PDF_API_GENERATED_DIR, "api_generated_one_table.pdf")
    try:
        # A more robust check for the dummy function might be needed if its signature changes
        if not callable(create_structured_pdf) or \
                (hasattr(create_structured_pdf,
                         '__doc__') and create_structured_pdf.__doc__ and "CRITICAL WARNING" in create_structured_pdf.__doc__):
            pytest.skip(
                "PDF generation utility 'create_structured_pdf' appears to be a dummy or not properly imported.")
        create_structured_pdf(file_path, "text_and_one_table")
    except pytest.skip.Exception:
        raise
    except Exception as e:
        if "reportlab" in str(e).lower() or "PIL" in str(e).lower():  # PIL/Pillow is a dep of reportlab
            pytest.skip(f"Skipping PDF test due to reportlab/PIL/PDF generation issue: {e}")
        pytest.fail(f"Failed to generate PDF for testing ('{file_path}'): {e}")

    if not os.path.exists(file_path):
        pytest.fail(f"PDF file was not generated by fixture: {file_path}. Check create_structured_pdf or permissions.")

    yield file_path
    if os.path.exists(file_path):
        os.remove(file_path)


@pytest.fixture
def api_generated_pdf_multiple_tables():
    """Generates a PDF with multiple structured tables for API testing."""
    file_path = os.path.join(PDF_API_GENERATED_DIR, "api_generated_multiple_tables.pdf")
    try:
        if not callable(create_structured_pdf) or \
                (hasattr(create_structured_pdf,
                         '__doc__') and create_structured_pdf.__doc__ and "CRITICAL WARNING" in create_structured_pdf.__doc__):
            pytest.skip(
                "PDF generation utility 'create_structured_pdf' appears to be a dummy or not properly imported.")
        create_structured_pdf(file_path, "multiple_tables")
    except pytest.skip.Exception:
        raise
    except Exception as e:
        if "reportlab" in str(e).lower() or "PIL" in str(e).lower():
            pytest.skip(f"Skipping PDF test due to reportlab/PIL/PDF generation issue: {e}")
        pytest.fail(f"Failed to generate PDF for testing ('{file_path}'): {e}")

    if not os.path.exists(file_path):
        pytest.fail(f"PDF file was not generated by fixture: {file_path}")

    yield file_path
    if os.path.exists(file_path):
        os.remove(file_path)


# --- PDF API Tests ---
def test_api_process_pdf_unsupported_output_format(client: TestClient, api_generated_pdf_one_table: str):
    """Test PDF processing with an unsupported output format using a generated PDF."""
    pdf_file_path = api_generated_pdf_one_table
    with open(pdf_file_path, "rb") as f:
        files = {"file": (os.path.basename(pdf_file_path), f, "application/pdf")}
        response = client.post("/process/document/?output_format=xml", files=files)  # xml is unsupported
    assert response.status_code == 400
    assert "Unsupported output format" in response.json()["detail"]


def test_api_process_pdf_success_json_output(client: TestClient, api_generated_pdf_one_table: str):
    """Test successful PDF processing via API (generated PDF), requesting JSON output."""
    pdf_file_path = api_generated_pdf_one_table
    with open(pdf_file_path, "rb") as f:
        files = {"file": (os.path.basename(pdf_file_path), f, "application/pdf")}
        response = client.post("/process/document/?output_format=json", files=files)

    assert response.status_code == 200, f"API Error: {response.text}"
    json_response = response.json()

    assert json_response["filename"] == os.path.basename(pdf_file_path)
    assert json_response["format"] == "json"
    assert json_response["source_type"] == "pdf"
    assert "extraction_date" in json_response
    try:
        date_str = json_response["extraction_date"]
        if date_str.endswith("Z"):  # Python <3.11 fromisoformat doesn't like Z
            date_str = date_str[:-1] + "+00:00"
        datetime.fromisoformat(date_str)
    except ValueError:
        pytest.fail(f"extraction_date is not a valid ISO 8601 format: {json_response['extraction_date']}")

    content_obj = json_response["content"]
    assert "extracted_text_with_placeholders" in content_obj
    assert "tables" in content_obj

    text_with_placeholders = content_obj["extracted_text_with_placeholders"]
    tables_array = content_obj["tables"]

    # Assertions updated based on your previously captured actual output for JSON
    expected_text_content_for_json = """PDF Test: Text before table.

[[INSERT_TABLE:table001]]

Header A (Col1)
Header B (Col2)
Data 1A
Data 1B
Data 2A
Data 2B
PDF Test: Text after table."""
    assert text_with_placeholders.strip() == expected_text_content_for_json.strip()

    assert isinstance(tables_array, list)
    assert len(tables_array) == 1

    table1 = tables_array[0]
    assert table1["id"] == "table001"
    assert table1["position"] == 1
    assert table1["caption"] is None
    assert table1["headers"] == ["Header A (Col1)", "Header B (Col2)"]
    assert table1["data"] == [
        ["Data 1A", "Data 1B"],
        ["Data 2A", "Data 2B"]
    ]
    assert table1.get("page_number") == 1


def test_api_process_pdf_success_text_output(client: TestClient, api_generated_pdf_one_table: str):
    """Test successful PDF processing via API (generated PDF), requesting plain text output."""
    pdf_file_path = api_generated_pdf_one_table
    with open(pdf_file_path, "rb") as f:
        files = {"file": (os.path.basename(pdf_file_path), f, "application/pdf")}
        response = client.post("/process/document/?output_format=text", files=files)

    assert response.status_code == 200, f"API Error: {response.text}"
    json_response = response.json()

    assert json_response["filename"] == os.path.basename(pdf_file_path)
    assert json_response["format"] == "text"
    assert json_response["source_type"] == "pdf"
    assert "extraction_date" in json_response

    content = json_response["content"]  # This is the plain text string

    # --- Assertions updated based on your previously captured actual output for TEXT ---
    # Main text part (which includes table cell text as extracted by PyMuPDF)
    assert "PDF Test: Text before table." in content
    assert "[[INSERT_TABLE:table001]]" in content
    assert "Header A (Col1)" in content
    assert "Header B (Col2)" in content
    assert "Data 1A" in content
    assert "Data 1B" in content
    assert "Data 2A" in content
    assert "Data 2B" in content
    assert "PDF Test: Text after table." in content

    # Referenced Table Data section (appended by to_plain_text.py)
    assert "--- Referenced Table Data ---" in content
    assert "--- table001 ---" in content
    # Asserting with tab as per to_plain_text.py's "\t".join()
    assert "Header A (Col1)\tHeader B (Col2)" in content
    assert "Data 1A\tData 1B" in content
    assert "Data 2A\tData 2B" in content

# TODO (User): Add similar tests (text and json output) for the 'api_generated_pdf_multiple_tables' fixture.
# You will need to:
# 1. Duplicate the test functions above (e.g., test_api_process_pdf_multiple_tables_success_json_output).
# 2. Change the fixture name in the function signature (e.g., `api_generated_pdf_multiple_tables`).
# 3. Run with temporary prints/fails (as you did for the single table PDF) to capture the
#    actual output for that multi-table PDF (text, number of tables, table IDs like table001 & table002,
#    their respective headers and data).
# 4. Update the assertions in these new duplicated tests to match that specific output.